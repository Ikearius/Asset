(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[321],{16801:(e,t)=>{"use strict";var s=t.uO={};s.read=function(e,t){return e.readFields(s._readField,{chunk:[],quantized_chunk:[]},t)},s._readField=function(e,t,s){1===e?t.chunk.push(a.read(s,s.readVarint()+s.pos)):2===e&&t.quantized_chunk.push(d.read(s,s.readVarint()+s.pos))},s.write=function(e,t){if(e.chunk)for(var s=0;s<e.chunk.length;s++)t.writeMessage(1,a.write,e.chunk[s]);if(e.quantized_chunk)for(s=0;s<e.quantized_chunk.length;s++)t.writeMessage(2,d.write,e.quantized_chunk[s])};var i={};i.read=function(e,t){return e.readFields(i._readField,{xyz:[],uv:[]},t)},i._readField=function(e,t,s){1===e?s.readPackedFloat(t.xyz):2===e&&s.readPackedFloat(t.uv)},i.write=function(e,t){e.xyz&&t.writePackedFloat(1,e.xyz),e.uv&&t.writePackedFloat(2,e.uv)};var r={};r.read=function(e,t){return e.readFields(r._readField,{faces:[]},t)},r._readField=function(e,t,s){1===e&&s.readPackedVarint(t.faces)},r.write=function(e,t){e.faces&&t.writePackedVarint(1,e.faces)};var a={};a.read=function(e,t){return e.readFields(a._readField,{vertices:null,faces:null,chunk_name:"",material_name:""},t)},a._readField=function(e,t,s){1===e?t.vertices=i.read(s,s.readVarint()+s.pos):2===e?t.faces=r.read(s,s.readVarint()+s.pos):3===e?t.chunk_name=s.readString():4===e&&(t.material_name=s.readString())},a.write=function(e,t){e.vertices&&t.writeMessage(1,i.write,e.vertices),e.faces&&t.writeMessage(2,r.write,e.faces),e.chunk_name&&t.writeStringField(3,e.chunk_name),e.material_name&&t.writeStringField(4,e.material_name)};var o={};o.read=function(e,t){return e.readFields(o._readField,{quantization:0,translation:[],x:[],y:[],z:[]},t)},o._readField=function(e,t,s){1===e?t.quantization=s.readFloat():2===e?s.readPackedFloat(t.translation):3===e?s.readPackedSVarint(t.x):4===e?s.readPackedSVarint(t.y):5===e&&s.readPackedSVarint(t.z)},o.write=function(e,t){e.quantization&&t.writeFloatField(1,e.quantization),e.translation&&t.writePackedFloat(2,e.translation),e.x&&t.writePackedSVarint(3,e.x),e.y&&t.writePackedSVarint(4,e.y),e.z&&t.writePackedSVarint(5,e.z)};var n={};n.read=function(e,t){return e.readFields(n._readField,{name:"",quantization:0,u:[],v:[]},t)},n._readField=function(e,t,s){1===e?t.name=s.readString():2===e?t.quantization=s.readFloat():3===e?s.readPackedSVarint(t.u):4===e&&s.readPackedSVarint(t.v)},n.write=function(e,t){e.name&&t.writeStringField(1,e.name),e.quantization&&t.writeFloatField(2,e.quantization),e.u&&t.writePackedSVarint(3,e.u),e.v&&t.writePackedSVarint(4,e.v)};var h={};h.read=function(e,t){return e.readFields(h._readField,{faces:[]},t)},h._readField=function(e,t,s){1===e&&s.readPackedSVarint(t.faces)},h.write=function(e,t){e.faces&&t.writePackedSVarint(1,e.faces)};var d={};d.read=function(e,t){return e.readFields(d._readField,{chunk_name:"",material_name:"",vertices:null,uvs:[],faces:null},t)},d._readField=function(e,t,s){1===e?t.chunk_name=s.readString():2===e?t.material_name=s.readString():3===e?t.vertices=o.read(s,s.readVarint()+s.pos):4===e?t.uvs.push(n.read(s,s.readVarint()+s.pos)):5===e&&(t.faces=r.read(s,s.readVarint()+s.pos))},d.write=function(e,t){if(e.chunk_name&&t.writeStringField(1,e.chunk_name),e.material_name&&t.writeStringField(2,e.material_name),e.vertices&&t.writeMessage(3,o.write,e.vertices),e.uvs)for(var s=0;s<e.uvs.length;s++)t.writeMessage(4,n.write,e.uvs[s]);e.faces&&t.writeMessage(5,r.write,e.faces)}},26203:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>MeshQueryModule});var i=s(88512),r=s(47724),a=s(17399),o=s(86488),n=s(26627);const h=(...e)=>function(t){return e.every((e=>e(t)))};var d=s(51245),l=s(2212);const u=new i.Z("mesh-query-module");class MeshQueryModule extends r.Y{constructor(){super(...arguments),this.name="mesh-query"}async init(e,t){const[s,i,r]=await Promise.all([t.market.waitForData(n.i),t.market.waitForData(o.Z),t.getModule(a.default)]);this.raycaster=r,this.floorData=s,this.roomData=i}nearestMeshInfoOnFloor(e,t){const s=h(d.$4.isRoomMesh,d.$4.matchesFloorId(t));return this.raycaster.picking.nearest((new l.Vector3).set(e.x,e.y,e.z),s)}nearestMeshInfo(e){return this.raycaster.picking.nearest((new l.Vector3).set(e.x,e.y,e.z),d.$4.isRoomMesh)}inferMeshIdsFromPoint(e,t){const s=!e.roomId||!this.roomData.get(e.roomId),i=!e.floorId||!this.floorData.hasFloor(e.floorId);if(s||i){const r=i?d.$4.isRoomMesh:h(d.$4.isRoomMesh,d.$4.matchesFloorId(e.floorId)),a=this.raycaster.picking.nearest((new l.Vector3).set(t.x,t.y,t.z),r);a&&d.$4.isRoomMesh(a.object)?(u.debug("data-fixup:",s?{roomId:a.object.roomId,prev:e.roomId}:"",i?{floorId:a.object.floorId,prev:e.floorId}:"",{data:e}),s&&(e.roomId=a.object.roomId),i&&(e.floorId=a.object.floorId)):u.warn("Nearest Room/Floor not found for:",{point:t,data:e,invalidRoomId:s,invalidFloorId:i})}return e}}},32653:(e,t,s)=>{"use strict";s.d(t,{s:()=>RoomMeshData});var i=s(32770);class RoomMeshData extends i.V{constructor(e,t,s){super(),this.name="room-mesh-data",this.root=e,this.floors=t,this.rooms=s}}},41659:(e,t,s)=>{"use strict";s.d(t,{u:()=>SetMeshOverlayCommand});var i,r,a=s(17386);!function(e){e.all="all",e.byFloorId="byFloorId",e.byRoomId="byRoomId",e.byMeshGroup="byMeshGroup",e.byMeshSubGroup="byMeshSubGroup"}(i||(i={})),function(e){e.explicit="explicit",e.random="random"}(r||(r={}));class SetMeshOverlayCommand extends a.m{constructor(e,t){super(),this.id="SET_MESH_OVERLAY_COLOR",this.payload={selectBy:(null==t?void 0:t.style)||i.all,colorStyle:(null==e?void 0:e.style)||r.explicit,color:(null==e?void 0:e.color)||null,alpha:(null==e?void 0:e.alpha)||.5,id:null==t?void 0:t.id,index:null==t?void 0:t.index}}}SetMeshOverlayCommand.selectBy=i,SetMeshOverlayCommand.colorBy=r,SetMeshOverlayCommand.COLOR_DIM={x:0,y:0,z:0,w:.3}},81638:(e,t,s)=>{"use strict";s.d(t,{I:()=>ToggleMeshOverlayColorCommand});var i=s(17386);class ToggleMeshOverlayColorCommand extends i.m{constructor(e){super(),this.id="TOGGLE_MESH_OVERLAY_COLOR",this.payload={enabled:e}}}},75872:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>ModelMeshModule});var i=s(47724),r=s(736),a=s(21479),o=s(12216),n=s(59088),h=s(26059),d=s(46114),l=s(44218),u=s(8445),c=s(17399),m=s(32306),p=s(29397),g=s(51764),f=s(85895),y=s(75892),M=s(64807),x=s(91302),w=s(68576),S=s(88814),v=s(35597),b=s(94329),k=s(79437),C=s(2212),T=s(25923),O=s(81638),D=s(59167),R=s(57937),B=s(17916),P=s(80301),F=s(67027);class MeshOverlayColor{constructor(e){this.getChunks=e,this.TOOL_MESH_COLOR_OVERLAY=new C.Vector4(0,0,0,.3),this.enabled=null,this.toggleEnabled=e=>{if(e!==this.enabled){for(const t of this.getChunks())t.setColorOverlay(e?this.TOOL_MESH_COLOR_OVERLAY:null);this.enabled=e}}}}var _=s(93331);class ModelCollider{constructor(e,t){this.input=e,this.mesh=t,this.clear()}dispose(){this.clear()}activate(e){const t={};for(const e of Object.keys(this.groupNames))for(const s of this.groupColliders[e])t[s.id]=!0,this.input.registerMesh(s,!0);for(const e of this.allColliders)t[e.id]||this.input.registerMesh(e,!0)}deactivate(e){for(const e of this.allColliders)this.input.unregisterMesh(e)}init(){for(const e of this.mesh.floorMeshes){let t=this.groupColliders[e.meshGroup];t||(this.groupColliders[e.meshGroup]=t=[]);for(const s of e.roomMeshes)t.push(s),this.allColliders.push(s)}}setSide(e){for(const t of this.allColliders)this.setSideRecursively(t,e)}setSideRecursively(e,t){e instanceof C.Mesh&&e.material&&e.material instanceof C.MeshBasicMaterial&&(e.material.side=t);for(const s of e.children)this.setSideRecursively(s,t)}getReadonlyColliderList(){return this.allColliders}getReadonlyColliderListForGroup(e){return this.groupColliders[e]}getGroupName(e){return this.groupNames[e]}render(){}setVisible(e){if(this._visible!==e){this._visible=e;for(const t of this.allColliders)t.visible=e}}clear(){this.allColliders=[],this.groupColliders={},this.groupNames={}}}var z=s(2388),I=s(3614),E=s(88512),U=s(75351),Q=s(56247);class ChunkMaterial extends C.RawShaderMaterial{constructor(e,t,s){const i={};for(const e of t)i[e]=!0;super({extensions:{derivatives:!0},fragmentShader:Q.Z.modelChunk.fragmentShader,vertexShader:Q.Z.modelChunk.vertexShader,uniforms:s,name:e,defines:i}),this.capabilities=t}}var A=s(22377);var L=s(10757);let G,V=1;try{G=function(e=16777215*Math.random(),t=1){const s=function(e,t,s,i=1){const r=document.createElement("canvas");r.width=t,r.height=s;const a=r.getContext("2d");return a.fillStyle=`rgba(${255*e.r|0},${255*e.g|0},${255*e.b|0}, ${255*i|0})`,a.fillRect(0,0,t,s),r}(new C.Color(e),1,1,t),i=new C.CubeTexture([s,s,s,s,s,s]);return i.format=C.RGBAFormat,i.needsUpdate=!0,i}(0,0)}catch(e){}const q=[{key:A.h.PanoTextureTransition,enabled:function(e){return e.progress.value>0&&e.progress.value<1&&e.pano0Map.value!==e.pano1Map.value},dependsOn:[A.h.PanoTexture],uniformsUsed:["progress","pano0Map","pano1Map"]},{key:A.h.PanoTexture,enabled:function(e){return e.panoOpacity.value>0},dependsOn:[],uniformsUsed:["panoOpacity"]},{key:A.h.ColorOverlay,enabled:function(e){return null!==e.colorOverlay.value},dependsOn:[],uniformsUsed:["colorOverlay"]},{key:A.h.MeshPreviewSphere,enabled:function(e){return null!==e.meshPreviewCenter.value},dependsOn:[A.h.MeshTexture],uniformsUsed:[]},{key:A.h.MeshTexture,enabled:function(e){return e.meshOpacity.value>0&&e.map.value},dependsOn:[],uniformsUsed:["meshOpacity","map"]},{key:A.h.Wireframe,enabled:function(e){return!1},dependsOn:[],uniformsUsed:[]},{key:A.h.FlatShading,enabled:function(e){return!1},dependsOn:[],uniformsUsed:[]},{key:A.h.PanoOverlay,enabled:function(e){return!!e.overlay0Map.value},dependsOn:[A.h.PanoTexture],uniformsUsed:["overlay0Map"]},{key:A.h.PanoOverlayTransition,enabled:function(e){return!!(e.progress.value>0&&e.progress.value<1&&e.overlay0Map.value&&e.overlay1Map.value&&e.overlay0Map.value!==e.overlay1Map.value)},dependsOn:[A.h.PanoOverlay,A.h.PanoTexture,A.h.PanoTextureTransition],uniformsUsed:["progress","overlay0Map","overlay1Map"]}],N=new Set(q.map((e=>e.uniformsUsed)).reduce(((e,t)=>e.concat(t)),[]));class Chunk{constructor(e,t,s,i=""){this.meshGroup=e,this.meshSubgroup=t,this.geometry=s,this.textureName=i,this.id=V++,this.name="",this.userData={},this.lod=B.V.Standard,this.renderingMode=U.S.Standard,this.chunkMaterials={},this.modeMaterials={},this.capabilityOverrides={},this.uniformCache=this.getUniformDefaults(),this.setProjectedPano=(()=>{const e=new C.Matrix4,t=new C.Matrix4,s=new C.Quaternion;return(i,r,a,o)=>{let n=1===i?"pano1Map":"pano0Map";const h={};h[n]=o||G,r&&(n=1===i?"pano1Position":"pano0Position",h[n]=r),a&&r&&(n=1===i?"pano1Matrix":"pano0Matrix",e.makeRotationFromQuaternion(s.copy(a).invert()),t.makeScale(-1,1,1),h[`${n}1`]=e,h[`${n}2`]=t),this.setMaterialsUniform(h)}})(),this.modeMaterials[U.S.Standard]=this.getChunkMaterial(this.getCapabilities()),this._material=this.modeMaterials[U.S.Standard];const r=C.UniformsUtils.clone(Q.Z.depth.uniforms);this.modeMaterials[U.S.Depth]=new C.RawShaderMaterial({fragmentShader:Q.Z.depth.fragmentShader,vertexShader:Q.Z.depth.vertexShader,uniforms:r,side:C.FrontSide,name:"materialDepth"});const a=C.UniformsUtils.clone(Q.Z.modelOutside.uniforms);a.opacity.value=.2,this.modeMaterials[U.S.Transparent]=new C.RawShaderMaterial({fragmentShader:Q.Z.modelOutside.fragmentShader,vertexShader:Q.Z.modelOutside.vertexShader,uniforms:a,side:C.FrontSide,transparent:!0,name:"materialTransparent"});const o=C.UniformsUtils.clone(Q.Z.modelOutside.uniforms);o.opacity.value=.5,o.colorOverlay.value.set(1,1,1,1),this.modeMaterials[U.S.Wireframe]=new C.RawShaderMaterial({fragmentShader:Q.Z.modelOutside.fragmentShader,vertexShader:Q.Z.modelOutside.vertexShader,uniforms:o,side:C.FrontSide,transparent:!0,wireframe:!0,name:"materialWireframe"})}getUniformDefaults(){const e={};for(const t in Q.Z.modelChunk.uniforms){const s=C.UniformsUtils.clone(Q.Z.modelChunk.uniforms[t]);for(const t in s)e[t]=s[t]}return e}set material(e){this._material!==e&&this.onMaterialUpdate&&this.onMaterialUpdate(e),this._material=e}get material(){return this._material}setMeshTexture(e){this.setMaterialsUniform({map:e})}setColorOverlay(e){this._colorOverlay!==e&&(this.setMaterialsUniform({colorOverlay:e}),this._colorOverlay=e)}setMeshTextureOpacity(e){e!==this._meshTextureOpacity&&(this.setMaterialsUniform({meshOpacity:e,panoOpacity:1-e}),this._meshTextureOpacity=e)}setProgress(e){this._progress!==e&&(this.setMaterialsUniform({progress:e}),this._progress=e)}setOpacity(e){e!==this.material.opacity&&(this.material.opacity=e,this.material.transparent=e<z.xx.FADE_OPAQUE,this.material.depthWrite=e>z.xx.FADE_DEPTH_WRITE_THRESHOLD,this.onOpacityUpdate&&this.onOpacityUpdate(e))}setTime(e){this.renderingMode===U.S.Wireframe&&this.setMaterialsUniform({time:e})}setTransparentDiscard(e){this.setMaterialsUniform({transparentDiscardDist:e})}setMeshPreviewSphere(e,t=.3){this.setMaterialsUniform({meshPreviewCenter:e,meshPreviewSize:t})}setWireframe(e){e&&(this.geometry.getIndex()&&this.geometry.copy(this.geometry.toNonIndexed()),function(e,t=!1){let s=e.getAttribute("barycentric");if(s)return s;const i=(e.getIndex()||e.getAttribute("position")).count/3,r=[];for(let e=0;e<i;e++){const s=t?1:0;e%2==0?r.push(0,0,1,0,1,0,1,0,s):r.push(0,1,0,0,0,1,1,0,s)}const a=new Float32Array(r);s=new C.BufferAttribute(a,3),e.setAttribute("barycentric",s)}(this.geometry)),this.overrideCapability(A.h.Wireframe,e)}setFlatShading(e){e&&this.geometry.computeVertexNormals(),this.overrideCapability(A.h.FlatShading,e)}getCapabilities(){const e=new Set;for(const t in this.capabilityOverrides)this.capabilityOverrides[t]&&e.add(t);for(const t of q)if(!e.has(t.key)&&t.enabled(this.uniformCache)){e.add(t.key);for(const s of t.dependsOn)e.add(s)}return e}overrideCapability(e,t){this.capabilityOverrides[e]=t,this.updateMaterialCapabilities()}updateMaterialCapabilities(){const e=this.getCapabilities(),t=this.modeMaterials[U.S.Standard];if((0,L.TH)(t.capabilities,e))return;const s=this.getChunkMaterial(e);s.side=t.side,s.transparent=t.transparent,s.depthWrite=t.depthWrite,this.modeMaterials[U.S.Standard]=s,this.renderingMode===U.S.Standard&&(this.material=s)}getChunkMaterial(e){let t="chunkMaterial_";for(const s of q)t+=e.has(s.key)?"1":"0";return this.chunkMaterials[t]||(this.chunkMaterials[t]=new ChunkMaterial(t,e,this.getUniformsForCapabilities(e))),this.chunkMaterials[t]}getUniformsForCapabilities(e){const t={};for(const s of e){const e=Q.Z.modelChunk.uniforms[s];for(const s in e)t[s]=this.uniformCache[s]}return t}setMaterialsUniform(e){let t,s=!0;const i=this.uniformCache.meshPreviewCenter.value;for(const r in e){const a=e[r];if(s="meshPreviewCenter"!==r?s||N.has(r):s||null===i!=(null===a),!(r in this.uniformCache))throw new Error(`Uniform ${r} does not exist in Chunk`);const o=this.uniformCache[r];o.value!==a&&(a&&(a.isVector3||a.isVector4||a.isMatrix3||a.isMatrix4||a.isColor)?null===o.value?o.value=a.clone():o.value.copy(a):o.value=a,"opacity"===r&&(t=a))}return s&&this.updateMaterialCapabilities(),void 0!==t&&this.setOpacity(t),this._material}setRenderingMode(e){this.renderingMode=e,this.material=this.modeMaterials[e]}setSide(e){for(const t in this.chunkMaterials)this.chunkMaterials[t].side=e}forEachMaterial(e){for(const t in this.chunkMaterials)e(this.chunkMaterials[t])}setOverlayPano(e,t,s){const i=`overlay${e}`,r={};if(t){const e=(new C.Matrix4).makeRotationFromQuaternion(t);r[i+"Matrix"]=e}r[i+"Map"]=s||G,this.setMaterialsUniform(r)}}const Z=new E.Z("dam-loader");class DamLoader{constructor(){this.decoder=s(16801).uO}async load(e,t,s){Z.time("download");const i=await t.getFile(e,{responseType:"arraybuffer",onProgress:s});return Z.timeEnd("download"),this.parse(i)}parse(e){Z.time("parse proto");const t=this.decoder.read(new I(e));Z.timeEnd("parse proto"),Z.time("convert to webgl");const s=this.convertProtobufToSceneObject(t);return Z.timeEnd("convert to webgl"),s}convertProtobufToSceneObject(e){if(0===e.chunk.length)return Z.warn("No chunks in damfile..."),[];const t=new C.Matrix4;return t.set(1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1),e.chunk.map((function(e){const s=new C.BufferGeometry;s.setAttribute("position",new C.BufferAttribute(new Float32Array(e.vertices.xyz,0,3),3)),e.vertices.uv.length>0&&s.setAttribute("uv",new C.BufferAttribute(new Float32Array(e.vertices.uv,0,2),2)),s.setIndex(new C.BufferAttribute(new Uint32Array(e.faces.faces,0,1),1)),s.applyMatrix4(t),s.computeBoundingBox();const{group:i,subgroup:r}=function(e){const t=e.match(/group([0-9]+)/),s=e.match(/sub([0-9]+)/),i=e.match(/type([0-9]+)/);return{group:t?parseInt(t[1],10):0,subgroup:s?parseInt(s[1],10):0,type:i?parseInt(i[1],10):0}}(e.chunk_name);return new Chunk(i,r,s,e.material_name)}))}}var $=s(38493),W=s(84561),j=s(31102);class MeshCreationException extends j.y{constructor(e){super(e),this.name="MeshCreationException"}}var H=s(21922);class FloorMesh extends C.Object3D{constructor(e,t=W.o.ALL){super(),this.renderLayer=t,this.roomMeshes=new $.Z((e=>e.meshSubgroup)),this.boundingBox=new C.Box3,this.size=new C.Vector3,this.center=new C.Vector3,this._chunks=[],this.built=!1,this.name=`FloorMesh:${e}`,this.meshGroup=e,this.floorId=void 0}dispose(){this.reset(),this.roomMeshes.clear()}reset(){for(const e of this.roomMeshes)e.dispose(),this.remove(e);this._chunks.length=0,this.built=!1}addChunk(e){const t=this.getOrCreateRoomMesh(e.meshSubgroup);this._chunks.push(e),t.addChunk(e)}build(){if(this.built)throw new Error("build() should only be called once");this.boundingBox.makeEmpty();for(const e of this.roomMeshes)this.add(e),this.boundingBox.union(e.boundingBox);this.center=this.boundingBox.getCenter(this.center),this.size=this.boundingBox.getSize(this.size),this.built=!0}get chunks(){return this._chunks}getOrCreateRoomMesh(e){let t=this.roomMeshes.get(e);return t||(t=new H.g(this.meshGroup,e,this.renderLayer),this.roomMeshes.add(t),this.add(t)),t}}const Y=new E.Z("mesh");class ModelMesh extends C.Object3D{constructor(e,t,s=W.o.ALL){super(),this.renderLayer=s,this.floorMeshes=new $.Z((e=>e.meshGroup)),this.boundingBox=new C.Box3,this.size=new C.Vector3,this.center=new C.Vector3,this.built=!1,this._chunks=[],this.uuid=e,this.name=`ModelMesh:${e}`,this.signedUrls=t,this.layers.mask=s.mask}dispose(){this.floorMeshes.mapElements((e=>{e.dispose(),this.remove(e)})),this.floorMeshes.clear(),this._chunks.length=0,this.built=!1}reset(){this.floorMeshes.mapElements((e=>{e.reset(),this.remove(e)})),this._chunks.length=0,this.built=!1}async load(e={}){let t=e.chunks?e.chunks:await class ModelLoader{static async load(e,t,s,i=0){const r=new DamLoader;z.ZP.highQualityDam&&0===i&&(i=1);const a=(t.meshUrls?t.meshUrls:[{suffix:"_50k",extension:"dam"},{suffix:"",extension:"dam"}])[i];if(!a)return Promise.reject("No suitable model file found...");const{url:o,suffix:n,extension:h}=a,d=o?await o.get():`${e}${n}.${h}`;return r.load(d,t,s).catch((()=>this.load(e,t,s,++i)))}}.load(this.uuid,this.signedUrls,e.onProgress).catch((e=>{Y.error(e);const t=e instanceof Error?e.message:"Failed to load model mesh";throw new MeshCreationException(t)}));if(0===t.length){Y.warn("No geometry found for model, loading faux geometry, disabling outside view-mode");const e=new C.PlaneBufferGeometry(5,5,1,1);e.rotateX(-Math.PI/2),e.computeBoundingBox();const s=new Chunk(0,0,e);s.forEachMaterial((e=>e.visible=!1)),t=[s]}return t.forEach(((e,t)=>{this.addChunk(e)})),this.build(),this}addChunk(e){const t=this.getOrCreateFloorMesh(e.meshGroup);this._chunks.push(e),t.addChunk(e)}build(){if(this.built)throw new Error("build() should only be called once");let e=0,t=0;for(const s of this.floorMeshes){this.add(s);for(const t of s.roomMeshes)t.build(),e++;s.build(),t++}Y.debug(`FloorMeshes: ${t} RoomMeshes: ${e} Chunks: ${this._chunks.length}`),this.boundingBox.makeEmpty();for(const e of this.floorMeshes)this.boundingBox.union(e.boundingBox);this.size=this.boundingBox.getSize(this.size),this.center=this.boundingBox.getCenter(this.center),this.built=!0}get roomMeshes(){const e=new Set;for(const t of this.floorMeshes)for(const s of t.roomMeshes)e.add(s);return e}get chunks(){return this._chunks}getOrCreateFloorMesh(e){let t=this.floorMeshes.get(e);return t||(t=new FloorMesh(e,this.renderLayer),this.floorMeshes.add(t),this.add(t)),t}}var J=s(55356),X=s(33874),K=s(24930),ee=s(48358);const te=new C.Vector3(0,0,0),se=new C.Vector3(100,100,100),ie=new C.Vector3,re=new C.Vector3,ae=new C.Box3;class FallbackMesh extends C.Mesh{constructor(){super(),this.bounds=new C.Box3,this.geometry=new C.BoxBufferGeometry(1,1,1),this.geometry.computeBoundingBox(),this.geometry.computeBoundingSphere(),this.chunk=new Chunk(-1,-1,this.geometry),this.chunk.onMaterialUpdate=e=>{this.material=e,this.material.side=C.BackSide,this.material.transparent=!0,this.material.depthWrite=!1},this.chunk.onMaterialUpdate(this.chunk.material),this.name="FallbackMesh",this.renderOrder=ee.z.boundingSkybox,this.setFromCenterAndSize(te,se)}setBounds(e){if(this.bounds.equals(e))return;this.bounds.copy(e);const t=e.getSize(ie);this.position.copy(e.getCenter(re)),this.scale.set(t.x,t.y,t.z),this.updateMatrixWorld(!0)}setFromCenterAndSize(e,t=se){this.setBounds(ae.setFromCenterAndSize(e,t))}}var oe=s(41659),ne=s(91670),he=s(17386);class SetPanoOverlayCommand extends he.m{constructor(e,t,s){super(),this.id="SET_PANO_OVERLAY",this.payload={sweepId:e,texture:t,quaternion:s}}}var de=s(8482);const le=new E.Z("modelrenderer");class ModelRenderer{constructor(e,t,s,i,r,a,o,n,h){this.scene=e,this.container=t,this.mesh=s,this.modelCollider=i,this.panoRenderer=r,this.meshData=a,this.sweepData=o,this.applicationData=n,this.renderOptions=h,this.chunkRenderingModeOverride=null,this.lastChunkRenderingModeOverride=null,this.fallbackMesh=new FallbackMesh,this.overlayTextures=[{sweepId:void 0,texture:void 0,renderTarget:new C.WebGLCubeRenderTarget(2048,{format:C.RGBAFormat}),quaternion:new C.Quaternion},{sweepId:void 0,texture:void 0,renderTarget:new C.WebGLCubeRenderTarget(2048,{format:C.RGBAFormat}),quaternion:new C.Quaternion}],this.overlayEnabled=!1,this.bindings=[],this.updateFallbackMesh=(()=>{const e=new C.Box3;return()=>{if(this.sweepData.currentAlignedSweepObject&&this.viewmodeData.currentMode===b.Ey.Panorama){const t=e.copy(this.meshData.bounds).expandByScalar(.2);this.fallbackMesh.setBounds(t)}else this.cameraData&&this.fallbackMesh.setFromCenterAndSize(this.cameraData.pose.position)}})(),this.debugColorizeChunks=(()=>{let e=!1;return(t,s)=>{const i=new C.Vector4(1,1,1,0);e=!e,(e=>{for(const t of this.mesh.chunks){const r=s?100*t.id:100*t.meshSubgroup,a=e?(0,J.G1)(.5,r):i;t.setColorOverlay(a)}})(t||e)}})()}init(){}dispose(){}async activate(e){this.engine=e,[this.viewmodeData,this.settings,this.cameraData,this.renderer]=await Promise.all([e.market.waitForData(v.O),e.market.waitForData(X.e),e.market.waitForData(n.M_),e.getModuleBySymbol(r.y.WEBGL_RENDERER)]),this.scene.add(this.container),this.scene.add(this.fallbackMesh),this.fallbackMesh.layers.mask=this.container.layers.mask,this.updateRenderState(),this.bindings.push(this.viewmodeData.onChanged(this.updateRenderState.bind(this)),this.sweepData.onChanged(this.updateRenderState.bind(this)),this.settings.onChanged(this.updateRenderState.bind(this)),e.commandBinder.addBinding(oe.u,this.onMeshOverlayCommand.bind(this)),e.commandBinder.addBinding(ne.U,this.onSetChunkRenderStateCommand.bind(this)),e.commandBinder.addBinding(SetPanoOverlayCommand,this.onPanoOverlayCommand.bind(this))),this.renderOptions.colorizeRooms&&this.debugColorizeChunks(!0),this.renderOptions.colorizeChunks&&this.debugColorizeChunks(!0,!0),this.renderOptions.wireframe&&this.toggleWireframe(!0),this.setupDebugMenu(e)}deactivate(){for(const e of this.bindings)e.cancel();this.bindings=[],this.scene.remove(this.container),this.scene.remove(this.fallbackMesh),this.currentSweepId&&this.panoRenderer.freeTexture(this.currentSweepId),this.currentSweepId=null,this.targetSweepId=null}updateSweepRenderTarget(e,t,s,i){const r=this.panoRenderer.useTexture(t);if(r)for(const t of this.allChunks())t.setProjectedPano(e,s,i,r)}*allChunks(){yield*this.mesh.chunks,yield this.fallbackMesh.chunk}updateExistingTexture(e,t,s,i){for(const r of this.allChunks())e===this.currentSweepId&&r.setProjectedPano(0,s,i,t),e===this.targetSweepId&&r.setProjectedPano(1,s,i,t)}render(){}beforeRender(){const e=!this.displayingUnaligned(this.sweepData,this.viewmodeData);this.container.visible=e,this.modelCollider.setVisible(e);const{floorOpacity:t,roomFadeDist:s}=this.meshData.meshGroupVisuals;for(const e of this.mesh.chunks){const i=t.get(e.meshGroup)||0,r=(0,de.t)(e.material.opacity,i,.2);e.setMaterialsUniform({meshOpacity:this.meshData.meshTextureOpacity.value,panoOpacity:1-this.meshData.meshTextureOpacity.value,opacity:r,transparentDiscardDist:s.get(e.meshSubgroup)||0,progress:this.sweepData.transition.progress.value})}const i=(0,k.w2)(this.meshData.meshTextureOpacity.value,0,1,1);this.fallbackMesh.chunk.setMeshTextureOpacity(i),this.fallbackMesh.chunk.setProgress(this.sweepData.transition.progress.value),this.updateFallbackMesh()}displayingUnaligned(e,t){return t.closestMode===b.Ey.Panorama&&!!e.currentSweep&&e.isSweepUnaligned(e.currentSweep)}updateChunkMaterialMode(e,t){const s=t||U.S.Standard,i=e?C.DoubleSide:C.FrontSide;for(const e of this.mesh.chunks)e.setRenderingMode(s),e.setSide(i)}updateChunkedColliderSide(e){const t=e===b.Ey.Panorama?C.DoubleSide:C.FrontSide;this.modelCollider.setSide(t)}updateRenderState(){if(this.container.visible=this.settings.tryGetProperty(z.AN,!0),this.viewmodeData.currentMode!==this.lastViewmode||this.lastChunkRenderingModeOverride!==this.chunkRenderingModeOverride){this.lastChunkRenderingModeOverride=this.chunkRenderingModeOverride;const e=this.viewmodeData.currentMode===b.Ey.Panorama;this.updateChunkMaterialMode(e,this.chunkRenderingModeOverride),this.viewmodeData.currentMode&&this.updateChunkedColliderSide(this.viewmodeData.currentMode),this.lastViewmode=this.viewmodeData.currentMode}if(this.viewmodeData.transition.active&&this.viewmodeData.transition.to===b.Ey.Panorama||this.viewmodeData.currentMode===b.Ey.Panorama){const e=this.sweepData.currentSweep,t=this.sweepData.transition,s=t.active&&(this.applicationData.phase===a.nh.PLAYING||this.applicationData.phase===a.nh.STARTING),i=s?t.from:e,r=s?t.to:e,o=this.currentSweepId,n=this.targetSweepId;this.currentSweepId=i||null,this.targetSweepId=r||null,this.handleSweepChange(0,o,this.currentSweepId),this.handleSweepChange(1,n,this.targetSweepId)}if(this.overlayEnabled){const e=this.overlayTextures.find((e=>e.sweepId===this.currentSweepId)),t=this.overlayTextures.find((e=>e.sweepId===this.targetSweepId));for(const s of this.allChunks())s.setOverlayPano(0,e?e.quaternion:void 0,e?e.texture:void 0),s.setOverlayPano(1,t?t.quaternion:void 0,t?t.texture:void 0)}}handleSweepChange(e,t,s){if(t!==s&&(t&&this.panoRenderer.freeTexture(t),s)){const t=this.sweepData.getSweep(s);this.updateSweepRenderTarget(e,s,t.position,t.rotation)}}async onPanoOverlayCommand(e){this.overlayEnabled=!0;const t=t=>{const s=t.renderTarget;t.renderTarget.width=e.texture.image.width,t.renderTarget.height=e.texture.image.height,t.sweepId=e.sweepId,t.texture=s.texture,t.quaternion=e.quaternion,this.renderer.cwfRenderer.copyCubemap(e.texture,t.renderTarget)};let s=!1;for(const i of this.overlayTextures)s||i.sweepId!==e.sweepId||(t(i),s=!0);for(const e of this.overlayTextures)s||e.sweepId===this.targetSweepId||e.sweepId===this.currentSweepId||(t(e),s=!0);this.updateRenderState()}async onMeshOverlayCommand(e){const t=this.meshData.meshGroups.rooms,s=this.meshData.meshGroups.roomIds,i=this.meshData.meshGroups.floors,r=this.meshData.meshGroups.floorIds;let a;switch(e.selectBy){case oe.u.selectBy.all:a=()=>!0;break;case oe.u.selectBy.byFloorId:a=t=>{let s=!1;for(const a of i)t.meshGroup===a.meshGroup&&r[t.meshGroup]===e.id&&(s=!0);return s};break;case oe.u.selectBy.byRoomId:a=i=>{let r=!1;for(const[a]of t)i.meshGroup===a&&s[i.meshSubgroup]===e.id&&(r=!0);return r};break;case oe.u.selectBy.byMeshGroup:a=t=>t.meshGroup===e.index;break;case oe.u.selectBy.byMeshSubGroup:a=t=>t.meshSubgroup===e.index}if(!a)return;let o="rand";e.colorStyle===oe.u.colorBy.explicit&&(o=e.color?new C.Vector4(e.color.x,e.color.y,e.color.z,e.color.w):null);for(const t of this.mesh.chunks)a(t)&&t.setColorOverlay("rand"===o?(0,J.G1)(e.alpha):o)}async onSetChunkRenderStateCommand(e){this.chunkRenderingModeOverride=e.mode,this.updateRenderState()}toggleWireframe(e){for(const t of this.mesh.chunks)t.setWireframe(e)}async setupDebugMenu(e){const[t,s]=await Promise.all([e.market.waitForData(X.e),e.getModule(K.default)]);s.registerButton("Mesh","Toggle visible",(()=>{this.container.visible=!this.container.visible})),s.registerButton("Mesh","Toggle depth",(()=>{const t=this.chunkRenderingModeOverride?null:U.S.Depth;e.commandBinder.issueCommand(new ne.U(t))})),s.registerButton("Mesh","Toggle transparent",(()=>{const t=this.chunkRenderingModeOverride?null:U.S.Transparent;e.commandBinder.issueCommand(new ne.U(t))})),s.registerButton("Mesh","Toggle wireframe",(()=>{const t=this.chunkRenderingModeOverride?null:U.S.Wireframe;e.commandBinder.issueCommand(new ne.U(t))}));let i=!1;s.registerButton("Mesh","Toggle flat shading",(()=>{i=!i;for(const e of this.mesh.chunks)e.setFlatShading(i)})),s.registerButton("Mesh","Cycle all chunk materials",(()=>{this.debugCycleChunkMaterials()})),s.registerButton("Mesh","Highlight Rooms",this.debugColorizeChunks),s.registerButton("Mesh","Highlight Chunks",(()=>this.debugColorizeChunks(!0,!0)));const r=(e,i,r,a,o)=>{s.registerSetting(e,i,r,!0,K.SettingPersistence.NONE,o),t.onPropertyChanged(i,a)};r("Wireframe",z.Lp,!1,this.toggleWireframe.bind(this));const a={[A.h.Wireframe]:{Wireframe:["thickness","wireframeOpacity","stroke","fillEnabled","fill","insideAltColor","dualStroke","secondThickness"],"Wireframe Dashes":["dashEnabled","dashLength","dashAnimate","dashOverlap"],"Wireframe Advanced":["squeeze","squeezeMin","squeezeMax"]}};for(const e in a){const t=Q.Z.modelChunk.uniforms[e];for(const s in a[e])for(const i of a[e][s])r(s,i,t[i].value,(e=>{for(const t of this.mesh.chunks)t.setMaterialsUniform({[i]:e})}),t[i].range)}}async debugCycleChunkMaterials(){const e=[];for(const t in A.h)isNaN(Number(t))&&e.push(A.h[t]);const t=[];for(const e in U.S)isNaN(Number(e))&&t.push(U.S[e]);le.info(`Available ChunkMaterialCapabilities: ${e}`);const s=[];for(let t=0;t<1<<e.length-1;t++){const i={};for(let s=e.length-1;s>=0;s--){i[e[s]]=Boolean(t&1<<s)}s.push(i)}le.info(`There are ${s.length*t.length} options to test`);for(let e=0;e<t.length;e++){await this.engine.commandBinder.issueCommand(new ne.U(e));for(const t of s){le.info(`Testing ChunkRenderingMode.${U.S[e]} with capabilities: ${JSON.stringify(t,void 0,2)}`);const s=new C.Vector4(Math.random(),Math.random(),Math.random(),.5);for(const e of Object.keys(t))for(const i of this.mesh.chunks)i.setColorOverlay(s),i.setMeshPreviewSphere(new C.Vector3(0,0,0)),i.overrideCapability(e,t[e]);await(0,L.gw)(100)}await(0,L.gw)(100)}await this.engine.commandBinder.issueCommand(new ne.U(null))}}var ue=s(76863),ce=s(28883);class MeshRenderPass{constructor(e,t){this.slots=e,this.renderToTextureModule=t,this.renderTarget=new C.WebGLRenderTarget(1,1),this.sizeMultiplier=1/8,this.pixelBuffer=new Uint8Array(4)}render(e,t,s=!1,i=!0){this.beforeRender();let{width:r,height:a}=this.renderToTextureModule.getRenderSize();r=Math.max(1,Math.floor(r*this.sizeMultiplier)),a=Math.max(1,Math.floor(a*this.sizeMultiplier)),r===this.renderTarget.width&&a===this.renderTarget.height||this.renderTarget.setSize(r,a),this.renderToTextureModule.render(this.renderTarget,e,t),s&&this.renderToScreen(),i&&this.afterRender()}renderToScreen(){this.renderToTextureModule.renderToScreen(this.renderTarget)}readPixels(){const e=this.renderTarget.width*this.renderTarget.height*4;this.pixelBuffer.length!==e&&(this.pixelBuffer=new Uint8Array(e));const t=this.pixelBuffer;return this.renderToTextureModule.getRenderTargetData(this.renderTarget,t),this.pixelBuffer}beforeRender(){for(const e of this.slots)for(const t of e.chunks)this.beforeRenderChunk(t,e)}afterRender(){for(const e of this.slots)for(const t of e.chunks)this.afterRenderChunk(t,e)}}class TextureQualityRenderPass extends MeshRenderPass{beforeRenderChunk(e,t){t.quality in t.config&&e.setColorOverlay(t.config[t.quality].debugColor)}afterRenderChunk(e,t){e.setColorOverlay(null)}}class TextureScoreRenderPass extends MeshRenderPass{beforeRender(){this.maxValue=this.slots.reduce(((e,t)=>Math.max(e,t.screenCoverageScore)),1e-9),super.beforeRender()}beforeRenderChunk(e,t){const s=t.screenCoverageScore/this.maxValue,i=new C.Vector4(s,s,s,1);e.setColorOverlay(i)}afterRenderChunk(e,t){e.setColorOverlay(null)}}var me=s(40324),pe=s(58232);class MeshTextureSlot{constructor(e,t,s=B.V.Standard){this.streamStyle=t,this.lod=s,this.chunks=new Set,this.loading=!1,this.screenCoverage=0,this.screenCoverageScore=0,this.sightings=new pe.P(100),this.textureName=e,this.streamStyle=t,this.lod=s,this.config=(0,me.lT)(this.streamStyle),this.minQuality=(0,me.q6)(this.streamStyle,s),this.maxQuality=this.minQuality,this.targetQuality=this.minQuality}setTexture(e){this.texture&&this.texture!==e&&this.texture.dispose(),this.texture=e;for(const e of this.chunks)e.setMeshTexture(this.texture)}async getUrl(e){const t=this.config[e].assetType;if(this.textureData){const e=this.textureName.match(/[_.]([0-9]{3})[_.]/);if(!e)throw new Error(`Could not parse texture index from texture name: ${this.textureName}`);return(await this.textureData[t].get()).urlTemplate.replace("<texture>",e[1])}{const e=this.textureName.match(/^([a-f0-9]+(_10k|_50k)?)/);if(!e)throw new Error(`Unknown format for texture name: ${this.textureName}`);return`${e[0]}_texture_jpg_${t}/${this.textureName}`}}addSighting(e,t,s){this.sightings.push({point:e,distance:t,time:s})}}class TextureBudgeter{constructor(){this.lods=new Map,this.orders={},this.qualMin=1/0,this.qualMax=-1/0}updateBudgetForStyle(e,t){this.streamStyle=e,this.slots=t,this.config=(0,me.lT)(e),t.forEach((t=>{this.orders[t.lod]=(0,me.Oc)(e,t.lod),this.qualMin=Math.min(this.qualMin,(0,me.q6)(e,t.lod));const s=this.lods.get(t.lod)||new Set;s.add(t),this.lods.set(t.lod,s)})),this.baseSizeUnit=this.config[this.qualMin].textureSize;let s=0;for(const[t,i]of this.lods.entries()){const r=(0,me.t3)(e,t);s+=i.size*this.getBudgetSize(r),this.qualMax=Math.max(this.qualMax,r)}return this.maxBudget=s,this.minBudget=this.slots.length,this._budget=this.minBudget,this}update(e){this.budget=this.maxBudget}getBudgetSize(e){return e?(this.config[e].textureSize/this.baseSizeUnit)**2:0}calcCurrentUsedBudget(){return this.slots.reduce(((e,t)=>e+this.getBudgetSize(t.quality)),0)}clampBudget(e){return Math.min(this.maxBudget,Math.max(this.minBudget,e))}get budget(){return this._budget}set budget(e){e=this.clampBudget(e),this.budget!==e&&(this._budget=e,this.updateTargetQualitiesFromBudget())}updateTargetQualitiesFromBudget(){let e=0;for(const t of this.slots)t.targetQuality=t.minQuality,e+=this.getBudgetSize(t.targetQuality);for(const[t,s]of this.lods.entries())for(const i of this.orders[t])for(const t of s)if(!(t.maxQuality<i)){if(e-=this.getBudgetSize(t.targetQuality),e+=this.getBudgetSize(i),e>this.budget)return;t.targetQuality=i}}}var ge=s(69626);const fe=[];let ye=0;var Me=s(27408),xe=s(67502);const we=new E.Z("/index.js");class MeshTextureLoader{constructor(e,t,s,i,r,a,o,n,h,d){this.textureLOD=e,this.urls=t,this.modelObject=s,this.camera=i,this.cameraData=r,this.renderer=a,this.renderToTextureModule=o,this.scene=n,this.engine=h,this.raycaster=d,this.name="texture-streaming",this.slots=[],this.textureNameToSlot={},this.concurrentLoadingTextures=3,this.concurrentDownloadingTiles=12,this.autoLoadTiles=!1,this.lastSortedAt=0,this.loadingTextures=0,this.downloadingTiles=0,this.totalTextures={},this.totalTiles=0,this.threeRaycaster=new C.Raycaster,this.textureQualityRenderPass=new TextureQualityRenderPass(this.slots,this.renderToTextureModule),this.textureScoreRenderPass=new TextureScoreRenderPass(this.slots,this.renderToTextureModule),this._chunkSlotsSet=new Set,this._raycastCounter=0}setModel(e,t,s,i){this.streamingStyle=e,this.textures=i,this.minQuality=(0,me.q6)(this.streamingStyle),this.maxQuality=(0,me.t3)(this.streamingStyle),this.modelObject=t,this.slots.length=0,this.textureNameToSlot={},this.addChunkSlots([...s]),this.textureBudgeter=(new TextureBudgeter).updateBudgetForStyle(this.streamingStyle,this.slots)}addChunkSlots(e){this._chunkSlotsSet.clear();let t=!1;for(const s of e){const e=s.textureName;let i=this.textureNameToSlot[e];i||(t=!0,i=new MeshTextureSlot(e,this.streamingStyle,s.lod),i.maxTextureAssetSize=s.maxTextureSize,this.textures&&(i.textureData=this.textures),this.textureNameToSlot[s.textureName]=i,this.slots.push(i)),i.chunks.has(s)||(t=!0,i.chunks.add(s)),this._chunkSlotsSet.add(i)}return t&&this.textureBudgeter&&this.textureBudgeter.updateBudgetForStyle(this.streamingStyle,this.slots),this._chunkSlotsSet}setQuality(e,t){if(e>t)throw new Error("min quality must be smaller or equal to max");this.minQuality=e,this.maxQuality=t;for(const e of this.slots)e.minQuality=this.minQuality,e.maxQuality=Math.min(e.maxQuality,this.maxQuality)}get textureCount(){return this.slots.length}loadAll(e){if(!this.slots[0]||!this.slots[0].textureName)return Promise.resolve([]);this.streamingStyle!==R.o.DAM&&we.error(`textureStreaming.loadAll(${me.S7[e]}) not supported with tiles, quality is different per lod`,this.slots);const t=this.slots.map((t=>this.loadTexture(t,e,!1)));return Promise.all(t)}async loadTexture(e,t,s=!0){const i=(0,me.lT)(this.streamingStyle);t in i||we.warn(me.S7[t],"not found in",this.streamingStyle,i);const r=i[t],a=e.maxTextureAssetSize||r.assetSize,o=Math.min(a,r.textureSize);e.lastLoadedAt=performance.now();let n=e.texture;if(n&&t===e.quality)return we.info(`Texture was already at level ${me.S7[t]}, not reloading`),e.texture;if(n&&t<e.quality){const s=this.renderToTextureModule.resizeTexture(n,o);return e.quality=t,e.setTexture(s),e.texture}n=new C.Texture,n.format=C.RGBFormat,this.renderer.initSizedTexture2D(o,n),e.loading=!0,this.loadingTextures++,this.totalTextures[o]=(this.totalTextures[o]||0)+1;try{n.sourceFile=await e.getUrl(t),this.textureLOD!==P.l.NONE&&s?await this.updateTextureTiled(n,t,e):await this.updateTextureSolid(n,t),e.setTexture(n)}catch(e){we.warn(`Failed loading texture ${n.sourceFile}`,e)}finally{this.loadingTextures--,e.quality=t,e.loading=!1}return n}async updateTextureTiled(e,t,s){e.generateMipmaps=!1,e.minFilter=C.LinearFilter,e.magFilter=C.LinearFilter;const i=(0,me.lT)(this.streamingStyle),r=void 0!==s.maxTextureAssetSize?s.maxTextureAssetSize:i[t].assetSize,a=Math.min(r,i[t].textureSize),o=Math.min(a,i[t].tileSize),n=r/(a/o),h=async(t,s)=>{const i={};let h;n!==o&&(i.width=`${o}`),n!==r&&(i.crop=`${n},${n},x${t/a},y${s/a}`),this.downloadingTiles+=1,this.totalTiles+=1;try{h=await this.urls.getImageBitmap(e.sourceFile,o,o,{priority:ce.RequestPriority.LOW,flipY:z.ZP.flipDownload},i)}finally{this.downloadingTiles-=1}const d=t,l=z.ZP.flipUpload?a-s-o:s;return(await this.engine.commandBinder.issueCommand(new xe._("mesh/texture/upload-tiles",(()=>this.renderer.uploadTexture2D(h,e,d,l)),100))).promise},d=[];for(let e=0;e<a;e+=o)for(let t=0;t<a;t+=o)d.push(h(e,t));return Promise.all(d).then((()=>{this.renderer.generateMipmaps(e)}))}async updateTextureSolid(e,t){const s=(0,me.lT)(this.streamingStyle),{textureSize:i}=s[t],r=z.ZP.flipDownload,a=await this.urls.getImageBitmap(e.sourceFile,i,i,{priority:ce.RequestPriority.LOW,flipY:r},{width:`${i}`});this.renderer.uploadTexture2D(a,e,0,0)}raycastRandomScreenLocation(e,t,s){this._raycastCounter++;const i=(2-2*t)/e,r=-1+t,a=this._raycastCounter%(e*e),o=a%e,n=r+(a-o)/e*i,h=r+o*i+Math.random()*i,d=n+Math.random()*i,l=new C.Vector3(h,d,-1).unproject(this.camera),u=new C.Vector3(h,d,1).unproject(this.camera).clone().sub(l).normalize(),c=[];if(this.streamingStyle===R.o.DAM){const e=this.raycaster.pick(l,u,ue.Pv);e&&c.push(e)}else this.streamingStyle===R.o.TILE&&this.threeRaycaster.set(l,u);const m=c[0];let p;if(m&&m.object&&m.object.visible){if(m.face&&m.object instanceof H.g){const e=m.object.getChunk(m.face.materialIndex);p=this.addChunkSlots([e])}m.object.userData.chunks&&(p=this.addChunkSlots(m.object.userData.chunks)),p&&p.size&&(s&&s(m),p.forEach((e=>e.addSighting(m.point.clone(),m.distance,this._raycastCounter))))}}analyzeTextureScreenCoverageFromRaycasts(){const e=window.innerWidth,t=(new C.Vector3).copy(this.cameraData.pose.position);for(const s of this.slots){s.screenCoverage=0,s.screenCoverageScore=0,s.maxQuality=s.minQuality;for(const i of s.sightings){if(this._raycastCounter-i.time>1e3)continue;const r=t.distanceTo(i.point),a=(0,ge._U)(r,this.camera.projectionMatrix,e);let o=(0,me.RQ)(a,this.streamingStyle,s.lod);o=Math.min(o,this.maxQuality),s.screenCoverageScore+=o,s.screenCoverage+=1,s.maxQuality=Math.max(o,s.maxQuality)}}this.slots.sort(((e,t)=>t.screenCoverageScore-e.screenCoverageScore)),this.textureBudgeter.updateTargetQualitiesFromBudget()}update(e){if(this.textureBudgeter.update(e),!this.camera||!this.autoLoadTiles)return;const t=performance.now();this.textureLOD===P.l.RAYCAST&&this.minQuality!==this.maxQuality&&(this.raycastTaskPromise||(this.raycastTaskPromise=this.engine.commandBinder.issueCommand(new xe._("mesh/texture/raycast",(()=>{this.raycastRandomScreenLocation(5,.05,z.ZP.debugLOD?((e,t)=>{if(0===fe.length)for(let e=0;e<100;e++){const e=new C.Mesh(new C.SphereBufferGeometry(.005),new C.MeshBasicMaterial);fe.push(e)}return s=>{const i=fe[ye++%fe.length];i.position.copy(s.point),i.scale.set(s.distance,s.distance,s.distance),i.material.color.setHex(e),i.parent||t.scene.add(i)}})(65280,this.scene):void 0)}),50)).then((async e=>{await e.promise,this.raycastTaskPromise=null}))),!this.analyzeTaskPromise&&t-this.lastSortedAt>200&&(this.analyzeTaskPromise=this.engine.commandBinder.issueCommand(new xe._("mesh/texture/analyze-screen-coverage",(()=>{this.analyzeTextureScreenCoverageFromRaycasts(),this.lastSortedAt=performance.now()}),100)).then((async e=>{await e.promise,this.analyzeTaskPromise=null}))));for(let e=this.slots.length-1;e>=0;e--){const s=this.slots[e],i=(0,Me.uZ)(s.targetQuality,s.minQuality,s.maxQuality),r=t-s.lastLoadedAt<1e3;if(!s.loading&&s.quality>i&&!r){this.loadTexture(s,i);break}}for(const e of this.slots){if(this.loadingTextures>=this.concurrentLoadingTextures||this.downloadingTiles>=this.concurrentDownloadingTiles)break;const t=(0,Me.uZ)(e.targetQuality,e.minQuality,e.maxQuality);!e.loading&&e.quality<t&&this.loadTexture(e,(0,me.Bl)(e.quality,this.streamingStyle,e.lod))}z.ZP.debugRttScores&&this.textureScoreRenderPass.render(this.modelObject,this.camera,!0,z.ZP.debugRttClear),z.ZP.debugRttQuality&&this.textureQualityRenderPass.render(this.modelObject,this.camera,!0,z.ZP.debugRttClear)}}var Se=s(32653);class ModelMeshModule extends i.Y{constructor(){super(...arguments),this.name="model-mesh",this.colorOverlay=null,this.toggleMeshOverlayColor=e=>{this.colorOverlay||(this.colorOverlay=new MeshOverlayColor((()=>this.modelMesh.chunks))),this.colorOverlay.toggleEnabled(e)},this.updateMaxQuality=(()=>{let e,t,s;return({modeChange:i,criticalChange:r,interactionChange:a})=>{void 0!==r&&(t=r),void 0!==i&&(e=i),void 0!==a&&(s=a);const o=s===h.s.VrOrientOnly||s===h.s.VrWithController||s===h.s.VrWithTrackedController,n=this.modelTextureLoader.textureCount<=this.config.textureLODThreshold?Math.max(me.S7.ULTRA,this.config.maxQuality):(0,me.Bl)((0,me.q6)(R.o.DAM,B.V.Standard),R.o.DAM,B.V.Standard),d=Math.max(n,e===b.Ey.Panorama&&0===this.meshData.meshTextureOpacity.value?n:this.config.maxQuality);this.modelTextureLoader.setQuality(n,d);const l=this.viewmodeData.currentMode!==b.Ey.Dollhouse&&this.viewmodeData.currentMode!==b.Ey.Floorplan,u=this.viewmodeData.transition.active&&this.viewmodeData.transition.to===b.Ey.Panorama;this.modelTextureLoader.autoLoadTiles=!(o||u||t&&l)&&this.config.textureLOD!==P.l.NONE}})()}async init(e,t){this.config=e,this.engine=t,this.market=t.market;const[s,i,o,h,d,p,g,f,x,w]=await Promise.all([t.getModuleBySymbol(r.y.WEBGL_RENDERER),t.getModule(c.default),t.getModule(l.default),t.market.waitForData(u.T),t.getModuleBySymbol(r.y.INPUT),t.getModule(m.default),t.market.waitForData(n.M_),t.market.waitForData(v.O),t.market.waitForData(y.Z),t.getModuleBySymbol(r.y.SWEEP_PANO)]);this.appData=await t.market.waitForData(a.pu),this.sweepData=x,this.viewmodeData=f;const S=s.getScene(),b=o.getSignedUrls(),k=h.model.uuid,C=t.claimRenderLayer(this.name);this.panoRenderer=w.getRenderer(),this.modelMesh=new ModelMesh(k,b,C),await this.modelMesh.load({onProgress:e=>{t.broadcast(new _.Z(e.loaded,e.total))}}),this.setupMarketData(this.modelMesh.chunks,x);const B=new Se.s(this.modelMesh,new Set(this.modelMesh.floorMeshes),this.modelMesh.roomMeshes);this.market.register(this,Se.s,B);let F=Promise.resolve();const z=this.modelMesh,I=this.modelMesh;if(e.renderMeshGeometry){this.modelTextureLoader=new MeshTextureLoader(e.textureLOD,b,z,S.camera,g,s.cwfRenderer,p,S,t,i.picking),this.modelTextureLoader.setModel(R.o.DAM,z,I.chunks,h.model.textures),this.updateMaxQuality({});const r=e.textureLOD!==P.l.NONE?me.S7.LOW:e.maxQuality;F=this.modelTextureLoader.loadAll(r).then((()=>{this.updateMaxQuality({})})),this.bindAppEventsToTextureQuality()}this.modelCollider=new ModelCollider(d,this.modelMesh),i.setupOctree(this.modelMesh),await t.addComponent(this,this.modelCollider),e.renderMeshGeometry&&(this.renderer=new ModelRenderer(S.scene,z,I,this.modelCollider,this.panoRenderer,this.meshData,this.sweepData,this.appData,e),await t.addComponent(this,this.renderer),await F),this.bindings.push(this.engine.subscribe(M.Z,(e=>{this.renderer.updateExistingTexture(e.sweepId,e.renderTarget.texture)}))),this.bindings.push(t.commandBinder.addBinding(T.g,(async e=>this.setMeshOpacity(e.value))),t.commandBinder.addBinding(O.I,(async e=>this.toggleMeshOverlayColor(e.enabled))),t.commandBinder.addBinding(D.n,this.setPreviewPosition.bind(this)))}onUpdate(e){this.modelTextureLoader&&!z.ZP.debugPauseTexStream&&this.modelTextureLoader.update(e),this.meshData.meshTextureOpacity.active&&(this.meshData.meshTextureOpacity.updateProgress(this.viewmodeData.transition.progress),this.meshData.commit());const t=performance.now()/1e3;for(const e of this.modelMesh.chunks)e.setTime(t)}get mesh(){return this.modelMesh}setupMarketData(e,t){const s=new Map,i=new Map,r=new C.Box3;e.forEach((e=>{e.geometry.boundingBox&&r.union(e.geometry.boundingBox),s.set(e.meshGroup,(s.get(e.meshGroup)||[]).concat(e)),i.set(e.meshSubgroup,(i.get(e.meshSubgroup)||[]).concat(e))}));const a=new C.Box3;t.iterate((e=>{e.isUnplaced()||(a.setFromCenterAndSize(e.position,o.f.UNIT),r.union(a))}));const n=new F._(0,[...r.min.toArray(),...r.max.toArray()]);for(const[e,t]of s.entries()){const s=new C.Box3;t.forEach((e=>{e.geometry.boundingBox&&s.union(e.geometry.boundingBox)})),n.meshGroups.floors.add({meshGroup:e,boundingBox:s,parentMeshGroup:null}),n.meshGroups.floorIds[e]=String(e);const r=[...new Set(t.map((e=>e.meshSubgroup)))].sort(((e,t)=>t-e));n.meshGroups.roomsByFloor.set(e,r);for(const t of r){const s=new C.Box3;(i.get(t)||[]).forEach((e=>{e.geometry.boundingBox&&s.union(e.geometry.boundingBox)}));const r={meshGroup:t,boundingBox:s,parentMeshGroup:e};n.meshGroups.rooms.has(t)&&this.log.warn("Duplicate room meshSubgroup found in model - \nold:",n.meshGroups.rooms.get(t),"\nnew:",r),n.meshGroups.rooms.set(t,r),n.meshGroups.roomIds[t]=String(t),n.meshGroupVisuals.roomFadeDist.set(t,0)}n.meshGroupVisuals.floorOpacity.set(e,1)}this.meshData=n,this.onMeshIdsUpdated(),this.meshData.onMeshIdsUpdated(this.onMeshIdsUpdated.bind(this)),this.market.register(this,F._,this.meshData)}onMeshIdsUpdated(){for(const e of this.mesh.floorMeshes){for(const t of e.roomMeshes)t.floorId=this.meshData.meshGroups.floorIds[t.meshGroup],t.roomId=this.meshData.meshGroups.roomIds[t.meshSubgroup];const t=this.meshData.meshGroups.floorIds[e.meshGroup];e.floorId=t}}startOpacityTransition(){const e=this.viewmodeData.transition.to,t=this.meshData.meshTextureOpacity.value,s=e===b.Ey.Panorama?0:1,i=e===b.Ey.Panorama?k.Q9:k.w2;this.meshData.meshTextureOpacity.value!==s&&this.meshData.meshTextureOpacity.modifyAnimation(t,s,1,i)}setMeshOpacity(e){this.meshData.meshTextureOpacity.modifyAnimation(e,e,0),this.meshData.commit()}bindAppEventsToTextureQuality(){let e=0;this.bindings.push(this.appData.onPropertyChanged("phase",(()=>this.updateMaxQuality({}))),this.meshData.onChanged((t=>{t.meshTextureOpacity!==e&&this.updateMaxQuality({}),e=t.meshTextureOpacity})),this.engine.subscribe(w.Z,(e=>{this.startOpacityTransition(),this.updateMaxQuality({criticalChange:!0,modeChange:e.toMode})})),this.engine.subscribe(S.Z,(e=>{this.updateMaxQuality({criticalChange:!1,modeChange:e.toMode})})),this.engine.subscribe(x.oR,(()=>{this.updateMaxQuality({criticalChange:!0})})),this.engine.subscribe(x.NR,(()=>{this.updateMaxQuality({criticalChange:!1})})),this.engine.subscribe(p.Z,(()=>{this.updateMaxQuality({criticalChange:!0})})),this.engine.subscribe(g.Z,(e=>{this.sweepData.getSweep(e.toSweep).isAligned()||this.setMeshOpacity(0)})),this.engine.subscribe(f.Z,(()=>{this.updateMaxQuality({criticalChange:!1})})),this.engine.subscribe(d.m,(e=>{this.updateMaxQuality({interactionChange:e.mode})})))}async setPreviewPosition(e){const t=e.enabled&&e.previewCirclePosition?e.previewCirclePosition:null,s=e.size?e.size:.3;for(const e of this.mesh.chunks)e.setMeshPreviewSphere(t,s)}}},64807:(e,t,s)=>{"use strict";s.d(t,{Z:()=>PanoRenderTargetResizedMessage});var i=s(91466);class PanoRenderTargetResizedMessage extends i.v{constructor(e,t,s){super(),this.size=e,this.sweepId=t,this.renderTarget=s}}}}]);